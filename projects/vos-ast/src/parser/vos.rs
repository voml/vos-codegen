// This file was generated by Peginator v0.3.0
// Hash of the grammar file: C746E7624EDE010A918CDCE92A8394FCF04AEC414BDB52E410A5B2885CDAFDB2
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone)]
pub struct VosParser {
    pub statements: Vec<VosStatementNode>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum VosStatementNode {
    ObjectStatementNode(ObjectStatementNode),
    Split(Split),
    StructDeclareNode(StructDeclareNode),
    TableDeclareNode(TableDeclareNode),
    UnionStatementNode(UnionStatementNode),
}
#[derive(Debug, Clone)]
pub struct TableDeclareNode {
    pub id: IdentifierNode,
    pub body: Vec<DeclareBodyNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct TableDeclare;
#[derive(Debug, Clone)]
pub struct StructDeclareNode {
    pub id: IdentifierNode,
    pub body: Vec<DeclareBodyNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct StructDeclare;
#[derive(Debug, Clone)]
pub struct DefineStatementNode {
    pub id: IdentifierNode,
    pub body: Vec<DeclareBodyNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct DefineDeclare;
#[derive(Debug, Clone)]
pub struct UnionStatementNode {
    pub id: IdentifierNode,
    pub body: Vec<UnionBodyNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct UnionDeclare;
#[derive(Debug, Clone)]
pub struct ObjectStatementNode {
    pub id: IdentifierNode,
    pub value: ValueNode,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct ObjectDeclare;
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum DeclareBodyNode {
    ConstraintStatementNode(ConstraintStatementNode),
    FieldStatementNode(FieldStatementNode),
    Split(Split),
}
#[derive(Debug, Clone)]
pub struct UnionBodyNode {
    pub id: IdentifierNode,
    pub n: Option<ValueNode>,
}
#[derive(Debug, Clone)]
pub struct FieldStatementNode {
    pub key: KeyNode,
    pub r#type: TypeValueNode,
    pub value: Option<ValueNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct TypeValueNode {
    pub name: NamespaceNode,
    pub generic: Option<GenericNode>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum GenericNode {
    GenericNum1(GenericNum1),
    GenericNum2(GenericNum2),
    GenericNum3(GenericNum3),
    NamespaceNode(NamespaceNode),
}
#[derive(Debug, Clone)]
pub struct GenericNum1 {
    pub token: GenericNum1Token,
    pub num: NumNode,
}
#[derive(Debug, Clone)]
pub struct GenericNum2 {
    pub num1: NumNode,
    pub token: GenericNum2Token,
    pub num2: NumNode,
}
#[derive(Debug, Clone)]
pub struct GenericNum3 {
    pub num1: NumNode,
    pub token1: GenericNum1Token,
    pub token2: GenericNum1Token,
    pub num2: NumNode,
}
#[derive(Debug, Clone)]
pub struct GenericNum1Token {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct GenericNum2Token {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct ConstraintStatementNode {
    pub key: KeyNode,
    pub value: Option<ValueNode>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum KeyNode {
    IdentifierNode(IdentifierNode),
    NumNode(NumNode),
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum ValueNode {
    DictNode(DictNode),
    ListNode(ListNode),
    NamespaceNode(NamespaceNode),
    NumNode(NumNode),
    SpecialNode(SpecialNode),
}
#[derive(Debug, Clone)]
pub struct DictNode {
    pub items: Vec<DictItem>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum DictItem {
    KeyValueNode(KeyValueNode),
    Split(Split),
}
#[derive(Debug, Clone)]
pub struct KeyValueNode {
    pub key: KeyNode,
    pub value: ValueNode,
}
#[derive(Debug, Clone)]
pub struct ListNode {
    pub items: Vec<ListItem>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum ListItem {
    Split(Split),
    ValueNode(ValueNode),
}
#[derive(Debug, Clone)]
pub struct NumNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct ModifierNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct NamespaceNode {
    pub path: Vec<IdentifierNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct IdentifierNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct SpecialNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
pub type XID_START = char;
pub type XID_CONTINUE = char;
pub type Dot = char;
pub type Split = char;
impl peginator_generated::PegParser for VosParser {
    fn parse_advanced<T: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_VosParser(
            peginator_generated::ParseState::new(s, settings),
            T::new(),
            &mut Default::default(),
        )?
        .result)
    }
}
#[allow(non_snake_case, unused_variables, unused_imports, unused_mut, dead_code)]
mod peginator_generated {
    use super::*;
    use peginator::runtime::*;
    pub use peginator::runtime::{IndentedTracer, ParseError, ParseSettings, ParseState, ParseTracer, PegParser, PegPosition};
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod VosParser_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut statements: Vec<VosStatementNode> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_VosStatementNode(state, tracer, cache))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            statements.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: statements, state })
            }
            pub type Parsed = Vec<VosStatementNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut statements, state } = part_0::parse(state, tracer, cache)?;
            let ParseOk { state, .. } =
                parse_Whitespace(state, tracer, cache).and_then(|ParseOk { state, .. }| parse_end_of_input(state))?;
            Ok(ParseOk { result: statements, state })
        }
        pub type Parsed = Vec<VosStatementNode>;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::VosParser> {
            let result = parse(state, tracer, cache)?.map(|r| super::VosParser { statements: r });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_VosParser<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, VosParser> {
        tracer.run_traced("VosParser", state, |state, tracer| VosParser_impl::rule_parser(state, tracer, cache))
    }
    mod VosStatementNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_TableDeclareNode(state, tracer, cache))
                        .map_inner(Parsed__override::TableDeclareNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_StructDeclareNode(state, tracer, cache))
                        .map_inner(Parsed__override::StructDeclareNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_ObjectStatementNode(state, tracer, cache))
                        .map_inner(Parsed__override::ObjectStatementNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_UnionStatementNode(state, tracer, cache))
                        .map_inner(Parsed__override::UnionStatementNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_Split(state, tracer, cache))
                        .map_inner(Parsed__override::Split)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::VosStatementNode as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::VosStatementNode> {
            let result = parse(state, tracer, cache)?;
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_VosStatementNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, VosStatementNode> {
        tracer.run_traced("VosStatementNode", state, |state, tracer| VosStatementNode_impl::rule_parser(state, tracer, cache))
    }
    mod TableDeclareNode_impl {
        use super::*;
        mod part_3 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut body: Vec<DeclareBodyNode> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_DeclareBodyNode(state, tracer, cache))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            body.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: body, state })
            }
            pub type Parsed = Vec<DeclareBodyNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_TableDeclare(state, tracer, cache))
                .discard_result()?;
            let ParseOk { result: id, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk { result: mut body, state } = part_3::parse(state, tracer, cache)?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            Ok(ParseOk { result: Parsed { id, body }, state })
        }
        pub struct Parsed {
            pub id: IdentifierNode,
            pub body: Vec<DeclareBodyNode>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::TableDeclareNode> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|r, new_state| super::TableDeclareNode {
                id: r.id,
                body: r.body,
                position: state.range_until(new_state),
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_TableDeclareNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, TableDeclareNode> {
        tracer.run_traced("TableDeclareNode", state, |state, tracer| TableDeclareNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for TableDeclareNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod TableDeclare_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "table"))
                .discard_result()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::TableDeclare> {
            let result = parse(state, tracer, cache)?.map(|r| super::TableDeclare {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_TableDeclare<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, TableDeclare> {
        tracer.run_traced("TableDeclare", state, |state, tracer| TableDeclare_impl::rule_parser(state, tracer, cache))
    }
    mod StructDeclareNode_impl {
        use super::*;
        mod part_3 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut body: Vec<DeclareBodyNode> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_DeclareBodyNode(state, tracer, cache))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            body.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: body, state })
            }
            pub type Parsed = Vec<DeclareBodyNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_StructDeclare(state, tracer, cache))
                .discard_result()?;
            let ParseOk { result: id, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk { result: mut body, state } = part_3::parse(state, tracer, cache)?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            Ok(ParseOk { result: Parsed { id, body }, state })
        }
        pub struct Parsed {
            pub id: IdentifierNode,
            pub body: Vec<DeclareBodyNode>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::StructDeclareNode> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|r, new_state| super::StructDeclareNode {
                id: r.id,
                body: r.body,
                position: state.range_until(new_state),
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_StructDeclareNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, StructDeclareNode> {
        tracer.run_traced("StructDeclareNode", state, |state, tracer| StructDeclareNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for StructDeclareNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod StructDeclare_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "class"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "struct"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "structure"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::StructDeclare> {
            let result = parse(state, tracer, cache)?.map(|r| super::StructDeclare {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_StructDeclare<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, StructDeclare> {
        tracer.run_traced("StructDeclare", state, |state, tracer| StructDeclare_impl::rule_parser(state, tracer, cache))
    }
    mod DefineStatementNode_impl {
        use super::*;
        mod part_3 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut body: Vec<DeclareBodyNode> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_DeclareBodyNode(state, tracer, cache))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            body.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: body, state })
            }
            pub type Parsed = Vec<DeclareBodyNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_DefineDeclare(state, tracer, cache))
                .discard_result()?;
            let ParseOk { result: id, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk { result: mut body, state } = part_3::parse(state, tracer, cache)?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            Ok(ParseOk { result: Parsed { id, body }, state })
        }
        pub struct Parsed {
            pub id: IdentifierNode,
            pub body: Vec<DeclareBodyNode>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::DefineStatementNode> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|r, new_state| super::DefineStatementNode {
                id: r.id,
                body: r.body,
                position: state.range_until(new_state),
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_DefineStatementNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, DefineStatementNode> {
        tracer.run_traced("DefineStatementNode", state, |state, tracer| {
            DefineStatementNode_impl::rule_parser(state, tracer, cache)
        })
    }
    impl PegPosition for DefineStatementNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod DefineDeclare_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "def"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "define"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "fn"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "fun"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "function"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::DefineDeclare> {
            let result = parse(state, tracer, cache)?.map(|r| super::DefineDeclare {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_DefineDeclare<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, DefineDeclare> {
        tracer.run_traced("DefineDeclare", state, |state, tracer| DefineDeclare_impl::rule_parser(state, tracer, cache))
    }
    mod UnionStatementNode_impl {
        use super::*;
        mod part_3 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut body: Vec<UnionBodyNode> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_UnionBodyNode(state, tracer, cache))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            body.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: body, state })
            }
            pub type Parsed = Vec<UnionBodyNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_UnionDeclare(state, tracer, cache))
                .discard_result()?;
            let ParseOk { result: id, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk { result: mut body, state } = part_3::parse(state, tracer, cache)?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            Ok(ParseOk { result: Parsed { id, body }, state })
        }
        pub struct Parsed {
            pub id: IdentifierNode,
            pub body: Vec<UnionBodyNode>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::UnionStatementNode> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|r, new_state| super::UnionStatementNode {
                id: r.id,
                body: r.body,
                position: state.range_until(new_state),
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_UnionStatementNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, UnionStatementNode> {
        tracer
            .run_traced("UnionStatementNode", state, |state, tracer| UnionStatementNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for UnionStatementNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod UnionDeclare_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "union"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "enum"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "enumerate"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "tagged"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::UnionDeclare> {
            let result = parse(state, tracer, cache)?.map(|r| super::UnionDeclare {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_UnionDeclare<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, UnionDeclare> {
        tracer.run_traced("UnionDeclare", state, |state, tracer| UnionDeclare_impl::rule_parser(state, tracer, cache))
    }
    mod ObjectStatementNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_ObjectDeclare(state, tracer, cache))
                .discard_result()?;
            let ParseOk { result: id, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '='))
                .discard_result()?;
            let ParseOk { result: value, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_ValueNode(state, tracer, cache))?;
            Ok(ParseOk { result: Parsed { id, value }, state })
        }
        pub struct Parsed {
            pub id: IdentifierNode,
            pub value: ValueNode,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ObjectStatementNode> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|r, new_state| super::ObjectStatementNode {
                id: r.id,
                value: r.value,
                position: state.range_until(new_state),
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ObjectStatementNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ObjectStatementNode> {
        tracer.run_traced("ObjectStatementNode", state, |state, tracer| {
            ObjectStatementNode_impl::rule_parser(state, tracer, cache)
        })
    }
    impl PegPosition for ObjectStatementNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ObjectDeclare_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "let"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "var"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "const"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "object"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ObjectDeclare> {
            let result = parse(state, tracer, cache)?.map(|r| super::ObjectDeclare {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ObjectDeclare<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ObjectDeclare> {
        tracer.run_traced("ObjectDeclare", state, |state, tracer| ObjectDeclare_impl::rule_parser(state, tracer, cache))
    }
    mod DeclareBodyNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_ConstraintStatementNode(state, tracer, cache))
                        .map_inner(Parsed__override::ConstraintStatementNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_FieldStatementNode(state, tracer, cache))
                        .map_inner(Parsed__override::FieldStatementNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_Split(state, tracer, cache))
                        .map_inner(Parsed__override::Split)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::DeclareBodyNode as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::DeclareBodyNode> {
            let result = parse(state, tracer, cache)?;
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_DeclareBodyNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, DeclareBodyNode> {
        tracer.run_traced("DeclareBodyNode", state, |state, tracer| DeclareBodyNode_impl::rule_parser(state, tracer, cache))
    }
    mod UnionBodyNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '='))
                        .discard_result()?;
                    let ParseOk { result: n, state } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_ValueNode(state, tracer, cache))
                        .map_inner(Some)?;
                    Ok(ParseOk { result: n, state })
                }
                pub type Parsed = Option<ValueNode>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), tracer, cache)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Option<ValueNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: id, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))?;
            let ParseOk { result: n, state } = part_1::parse(state, tracer, cache)?;
            Ok(ParseOk { result: Parsed { id, n }, state })
        }
        pub struct Parsed {
            pub id: IdentifierNode,
            pub n: Option<ValueNode>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::UnionBodyNode> {
            let result = parse(state, tracer, cache)?.map(|r| super::UnionBodyNode { id: r.id, n: r.n });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_UnionBodyNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, UnionBodyNode> {
        tracer.run_traced("UnionBodyNode", state, |state, tracer| UnionBodyNode_impl::rule_parser(state, tracer, cache))
    }
    mod FieldStatementNode_impl {
        use super::*;
        mod part_3 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '='))
                        .discard_result()?;
                    let ParseOk { result: value, state } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_ValueNode(state, tracer, cache))
                        .map_inner(Some)?;
                    Ok(ParseOk { result: value, state })
                }
                pub type Parsed = Option<ValueNode>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), tracer, cache)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Option<ValueNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: key, state } =
                parse_Whitespace(state, tracer, cache).and_then(|ParseOk { state, .. }| parse_KeyNode(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                .discard_result()?;
            let ParseOk { result: r#type, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_TypeValueNode(state, tracer, cache))?;
            let ParseOk { result: value, state } = part_3::parse(state, tracer, cache)?;
            Ok(ParseOk { result: Parsed { key, r#type, value }, state })
        }
        pub struct Parsed {
            pub key: KeyNode,
            pub r#type: TypeValueNode,
            pub value: Option<ValueNode>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::FieldStatementNode> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|r, new_state| super::FieldStatementNode {
                key: r.key,
                r#type: r.r#type,
                value: r.value,
                position: state.range_until(new_state),
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_FieldStatementNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, FieldStatementNode> {
        tracer
            .run_traced("FieldStatementNode", state, |state, tracer| FieldStatementNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for FieldStatementNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod TypeValueNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '['))
                        .discard_result()?;
                    let ParseOk { result: generic, state } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_GenericNode(state, tracer, cache))
                        .map_inner(Some)?;
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ']'))
                        .discard_result()?;
                    Ok(ParseOk { result: generic, state })
                }
                pub type Parsed = Option<GenericNode>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), tracer, cache)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Option<GenericNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: name, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_NamespaceNode(state, tracer, cache))?;
            let ParseOk { result: generic, state } = part_1::parse(state, tracer, cache)?;
            Ok(ParseOk { result: Parsed { name, generic }, state })
        }
        pub struct Parsed {
            pub name: NamespaceNode,
            pub generic: Option<GenericNode>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::TypeValueNode> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|r, new_state| super::TypeValueNode {
                name: r.name,
                generic: r.generic,
                position: state.range_until(new_state),
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_TypeValueNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, TypeValueNode> {
        tracer.run_traced("TypeValueNode", state, |state, tracer| TypeValueNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for TypeValueNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod GenericNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_GenericNum1(state, tracer, cache))
                        .map_inner(Parsed__override::GenericNum1)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_GenericNum2(state, tracer, cache))
                        .map_inner(Parsed__override::GenericNum2)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_GenericNum3(state, tracer, cache))
                        .map_inner(Parsed__override::GenericNum3)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_NamespaceNode(state, tracer, cache))
                        .map_inner(Parsed__override::NamespaceNode)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::GenericNode as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::GenericNode> {
            let result = parse(state, tracer, cache)?;
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_GenericNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, GenericNode> {
        tracer.run_traced("GenericNode", state, |state, tracer| GenericNode_impl::rule_parser(state, tracer, cache))
    }
    mod GenericNum1_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: token, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_GenericNum1Token(state, tracer, cache))?;
            let ParseOk { result: num, state } =
                parse_Whitespace(state, tracer, cache).and_then(|ParseOk { state, .. }| parse_NumNode(state, tracer, cache))?;
            Ok(ParseOk { result: Parsed { token, num }, state })
        }
        pub struct Parsed {
            pub token: GenericNum1Token,
            pub num: NumNode,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::GenericNum1> {
            let result = parse(state, tracer, cache)?.map(|r| super::GenericNum1 { token: r.token, num: r.num });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_GenericNum1<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, GenericNum1> {
        tracer.run_traced("GenericNum1", state, |state, tracer| GenericNum1_impl::rule_parser(state, tracer, cache))
    }
    mod GenericNum2_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: num1, state } =
                parse_Whitespace(state, tracer, cache).and_then(|ParseOk { state, .. }| parse_NumNode(state, tracer, cache))?;
            let ParseOk { result: token, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_GenericNum2Token(state, tracer, cache))?;
            let ParseOk { result: num2, state } =
                parse_Whitespace(state, tracer, cache).and_then(|ParseOk { state, .. }| parse_NumNode(state, tracer, cache))?;
            Ok(ParseOk { result: Parsed { num1, token, num2 }, state })
        }
        pub struct Parsed {
            pub num1: NumNode,
            pub token: GenericNum2Token,
            pub num2: NumNode,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::GenericNum2> {
            let result =
                parse(state, tracer, cache)?.map(|r| super::GenericNum2 { num1: r.num1, token: r.token, num2: r.num2 });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_GenericNum2<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, GenericNum2> {
        tracer.run_traced("GenericNum2", state, |state, tracer| GenericNum2_impl::rule_parser(state, tracer, cache))
    }
    mod GenericNum3_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: num1, state } =
                parse_Whitespace(state, tracer, cache).and_then(|ParseOk { state, .. }| parse_NumNode(state, tracer, cache))?;
            let ParseOk { result: token1, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_GenericNum1Token(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))
                .discard_result()?;
            let ParseOk { result: token2, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_GenericNum1Token(state, tracer, cache))?;
            let ParseOk { result: num2, state } =
                parse_Whitespace(state, tracer, cache).and_then(|ParseOk { state, .. }| parse_NumNode(state, tracer, cache))?;
            Ok(ParseOk { result: Parsed { num1, token1, token2, num2 }, state })
        }
        pub struct Parsed {
            pub num1: NumNode,
            pub token1: GenericNum1Token,
            pub token2: GenericNum1Token,
            pub num2: NumNode,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::GenericNum3> {
            let result = parse(state, tracer, cache)?.map(|r| super::GenericNum3 {
                num1: r.num1,
                token1: r.token1,
                token2: r.token2,
                num2: r.num2,
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_GenericNum3<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, GenericNum3> {
        tracer.run_traced("GenericNum3", state, |state, tracer| GenericNum3_impl::rule_parser(state, tracer, cache))
    }
    mod GenericNum1Token_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "<="))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, ">="))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ''))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ''))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ''))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ''))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '<'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '>'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '='))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, GenericNum1Token> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                GenericNum1Token { string, position: state.range_until(new_state) }
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_GenericNum1Token<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, GenericNum1Token> {
        tracer.run_traced("GenericNum1Token", state, |state, tracer| GenericNum1Token_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for GenericNum1Token {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod GenericNum2Token_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "..="))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "..<"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, GenericNum2Token> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                GenericNum2Token { string, position: state.range_until(new_state) }
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_GenericNum2Token<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, GenericNum2Token> {
        tracer.run_traced("GenericNum2Token", state, |state, tracer| GenericNum2Token_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for GenericNum2Token {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ConstraintStatementNode_impl {
        use super::*;
        mod part_2 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                        .discard_result()?;
                    let ParseOk { result: value, state } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_ValueNode(state, tracer, cache))
                        .map_inner(Some)?;
                    Ok(ParseOk { result: value, state })
                }
                pub type Parsed = Option<ValueNode>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), tracer, cache)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Option<ValueNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '^'))
                .discard_result()?;
            let ParseOk { result: key, state } =
                parse_Whitespace(state, tracer, cache).and_then(|ParseOk { state, .. }| parse_KeyNode(state, tracer, cache))?;
            let ParseOk { result: value, state } = part_2::parse(state, tracer, cache)?;
            Ok(ParseOk { result: Parsed { key, value }, state })
        }
        pub struct Parsed {
            pub key: KeyNode,
            pub value: Option<ValueNode>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ConstraintStatementNode> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|r, new_state| super::ConstraintStatementNode {
                key: r.key,
                value: r.value,
                position: state.range_until(new_state),
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ConstraintStatementNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ConstraintStatementNode> {
        tracer.run_traced("ConstraintStatementNode", state, |state, tracer| {
            ConstraintStatementNode_impl::rule_parser(state, tracer, cache)
        })
    }
    impl PegPosition for ConstraintStatementNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod KeyNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))
                        .map_inner(Parsed__override::IdentifierNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_NumNode(state, tracer, cache))
                        .map_inner(Parsed__override::NumNode)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::KeyNode as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::KeyNode> {
            let result = parse(state, tracer, cache)?;
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_KeyNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, KeyNode> {
        tracer.run_traced("KeyNode", state, |state, tracer| KeyNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for KeyNode {
        fn position(&self) -> &std::ops::Range<usize> {
            match self {
                Self::IdentifierNode(x) => x.position(),
                Self::NumNode(x) => x.position(),
            }
        }
    }
    mod ValueNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_DictNode(state, tracer, cache))
                        .map_inner(Parsed__override::DictNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_ListNode(state, tracer, cache))
                        .map_inner(Parsed__override::ListNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_SpecialNode(state, tracer, cache))
                        .map_inner(Parsed__override::SpecialNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_NumNode(state, tracer, cache))
                        .map_inner(Parsed__override::NumNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_NamespaceNode(state, tracer, cache))
                        .map_inner(Parsed__override::NamespaceNode)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::ValueNode as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ValueNode> {
            let result = parse(state, tracer, cache)?;
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ValueNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ValueNode> {
        tracer.run_traced("ValueNode", state, |state, tracer| ValueNode_impl::rule_parser(state, tracer, cache))
    }
    mod DictNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut items: Vec<DictItem> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_DictItem(state, tracer, cache))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            items.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: items, state })
            }
            pub type Parsed = Vec<DictItem>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk { result: mut items, state } = part_1::parse(state, tracer, cache)?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            Ok(ParseOk { result: items, state })
        }
        pub type Parsed = Vec<DictItem>;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::DictNode> {
            let result = parse(state.clone(), tracer, cache)?
                .map_with_state(|r, new_state| super::DictNode { items: r, position: state.range_until(new_state) });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_DictNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, DictNode> {
        tracer.run_traced("DictNode", state, |state, tracer| DictNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for DictNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod DictItem_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_KeyValueNode(state, tracer, cache))
                        .map_inner(Parsed__override::KeyValueNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_Split(state, tracer, cache))
                        .map_inner(Parsed__override::Split)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::DictItem as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::DictItem> {
            let result = parse(state, tracer, cache)?;
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_DictItem<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, DictItem> {
        tracer.run_traced("DictItem", state, |state, tracer| DictItem_impl::rule_parser(state, tracer, cache))
    }
    mod KeyValueNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: key, state } =
                parse_Whitespace(state, tracer, cache).and_then(|ParseOk { state, .. }| parse_KeyNode(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                .discard_result()?;
            let ParseOk { result: value, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_ValueNode(state, tracer, cache))?;
            Ok(ParseOk { result: Parsed { key, value }, state })
        }
        pub struct Parsed {
            pub key: KeyNode,
            pub value: ValueNode,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::KeyValueNode> {
            let result = parse(state, tracer, cache)?.map(|r| super::KeyValueNode { key: r.key, value: r.value });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_KeyValueNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, KeyValueNode> {
        tracer.run_traced("KeyValueNode", state, |state, tracer| KeyValueNode_impl::rule_parser(state, tracer, cache))
    }
    mod ListNode_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut items: Vec<ListItem> = Vec::new();
                    loop {
                        match parse_Whitespace(state.clone(), tracer, cache)
                            .and_then(|ParseOk { state, .. }| parse_ListItem(state, tracer, cache))
                            .map_inner(|result| vec![result])
                        {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                items.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: items, state })
                }
                pub type Parsed = Vec<ListItem>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '['))
                    .discard_result()?;
                let ParseOk { result: mut items, state } = part_1::parse(state, tracer, cache)?;
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ']'))
                    .discard_result()?;
                Ok(ParseOk { result: items, state })
            }
            pub type Parsed = Vec<ListItem>;
        }
        mod choice_1 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut items: Vec<ListItem> = Vec::new();
                    loop {
                        match parse_Whitespace(state.clone(), tracer, cache)
                            .and_then(|ParseOk { state, .. }| parse_ListItem(state, tracer, cache))
                            .map_inner(|result| vec![result])
                        {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                items.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: items, state })
                }
                pub type Parsed = Vec<ListItem>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                    .discard_result()?;
                let ParseOk { result: mut items, state } = part_1::parse(state, tracer, cache)?;
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                    .discard_result()?;
                Ok(ParseOk { result: items, state })
            }
            pub type Parsed = Vec<ListItem>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state.clone(), tracer, cache))
                .choice(|state| choice_1::parse(state.clone(), tracer, cache))
                .end()
        }
        pub type Parsed = Vec<ListItem>;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ListNode> {
            let result = parse(state.clone(), tracer, cache)?
                .map_with_state(|r, new_state| super::ListNode { items: r, position: state.range_until(new_state) });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ListNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ListNode> {
        tracer.run_traced("ListNode", state, |state, tracer| ListNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for ListNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ListItem_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_ValueNode(state, tracer, cache))
                        .map_inner(Parsed__override::ValueNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_Split(state, tracer, cache))
                        .map_inner(Parsed__override::Split)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::ListItem as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ListItem> {
            let result = parse(state, tracer, cache)?;
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ListItem<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ListItem> {
        tracer.run_traced("ListItem", state, |state, tracer| ListItem_impl::rule_parser(state, tracer, cache))
    }
    mod NumNode_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match parse_character_range(state.clone(), '0', '9').discard_result() {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                if iterations == 0 {
                    return Err(state.report_farthest_error());
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        mod part_1 {
            use super::*;
            mod optional {
                use super::*;
                mod part_1 {
                    use super::*;
                    mod closure {
                        use super::*;
                    }
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let mut iterations: usize = 0;
                        let mut state = state;
                        loop {
                            match parse_character_range(state.clone(), '0', '9').discard_result() {
                                Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                    state = new_state;
                                }
                                Err(err) => {
                                    state = state.record_error(err);
                                    break;
                                }
                            }
                            iterations += 1;
                        }
                        if iterations == 0 {
                            return Err(state.report_farthest_error());
                        }
                        Ok(ParseOk { result: (), state })
                    }
                    pub type Parsed = ();
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Dot(state, tracer, cache).discard_result()?;
                    let ParseOk { state, .. } = part_1::parse(state, tracer, cache)?;
                    Ok(ParseOk { result: (), state })
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), tracer, cache)
                    .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = part_0::parse(state, tracer, cache)?;
            let ParseOk { state, .. } = part_1::parse(state, tracer, cache)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, NumNode> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                NumNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_NumNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, NumNode> {
        tracer.run_traced("NumNode", state, |state, tracer| NumNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for NumNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ModifierNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod negative_lookahead {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    mut state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    ChoiceHelper::new(state)
                        .choice(|state| {
                            parse_Whitespace(state, tracer, cache)
                                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                                .discard_result()
                        })
                        .choice(|state| {
                            parse_Whitespace(state, tracer, cache)
                                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '['))
                                .discard_result()
                        })
                        .end()
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                match negative_lookahead::parse(state.clone(), tracer, cache) {
                    Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                    Err(_) => Ok(ParseOk { result: (), state }),
                }
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))
                .discard_result()?;
            let ParseOk { state, .. } = part_1::parse(state, tracer, cache)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, ModifierNode> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                ModifierNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ModifierNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ModifierNode> {
        tracer.run_traced("ModifierNode", state, |state, tracer| ModifierNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for ModifierNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod NamespaceNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = ChoiceHelper::new(state)
                        .choice(|state| {
                            parse_Whitespace(state, tracer, cache)
                                .and_then(|ParseOk { state, .. }| parse_Dot(state, tracer, cache))
                                .discard_result()
                        })
                        .choice(|state| {
                            parse_Whitespace(state, tracer, cache)
                                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "::"))
                                .discard_result()
                        })
                        .end()?;
                    let ParseOk { result: mut path, state } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))
                        .map_inner(|result| vec![result])?;
                    Ok(ParseOk { result: path, state })
                }
                pub type Parsed = Vec<IdentifierNode>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut path: Vec<IdentifierNode> = Vec::new();
                loop {
                    match closure::parse(state.clone(), tracer, cache) {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            path.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: path, state })
            }
            pub type Parsed = Vec<IdentifierNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut path, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))
                .map_inner(|result| vec![result])?;
            let ParseOk { result: extend_path_with, state } = part_1::parse(state, tracer, cache)?;
            path.extend(extend_path_with);
            Ok(ParseOk { result: path, state })
        }
        pub type Parsed = Vec<IdentifierNode>;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::NamespaceNode> {
            let result = parse(state.clone(), tracer, cache)?
                .map_with_state(|r, new_state| super::NamespaceNode { path: r, position: state.range_until(new_state) });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_NamespaceNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, NamespaceNode> {
        tracer.run_traced("NamespaceNode", state, |state, tracer| NamespaceNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for NamespaceNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod IdentifierNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match parse_XID_CONTINUE(state.clone(), tracer, cache).discard_result() {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = ChoiceHelper::new(state)
                .choice(|state| parse_XID_START(state, tracer, cache).discard_result())
                .choice(|state| parse_character_literal(state, '_').discard_result())
                .end()?;
            let ParseOk { state, .. } = part_1::parse(state, tracer, cache)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, IdentifierNode> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                IdentifierNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_IdentifierNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, IdentifierNode> {
        tracer.run_traced("IdentifierNode", state, |state, tracer| IdentifierNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for IdentifierNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod SpecialNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "null"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "default"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "true"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "false"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, SpecialNode> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                SpecialNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_SpecialNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, SpecialNode> {
        tracer.run_traced("SpecialNode", state, |state, tracer| SpecialNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for SpecialNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    #[inline]
    pub(super) fn parse_XID_START<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, XID_START> {
        if let Some(c) = state.s().chars().next() {
            if !unicode_ident::is_xid_start(c) {
                return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }));
            }
        }
        else {
            return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }));
        }
        if let Ok(result) = parse_char(state.clone(), tracer, cache) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }))
    }
    #[inline]
    pub(super) fn parse_XID_CONTINUE<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, XID_CONTINUE> {
        if let Some(c) = state.s().chars().next() {
            if !unicode_ident::is_xid_continue(c) {
                return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }));
            }
        }
        else {
            return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }));
        }
        if let Ok(result) = parse_char(state.clone(), tracer, cache) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }))
    }
    #[inline]
    pub(super) fn parse_Dot<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Dot> {
        if let Ok(result) = parse_character_literal(state.clone(), '.') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "Dot" }))
    }
    #[inline]
    pub(super) fn parse_Split<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Split> {
        if let Ok(result) = parse_character_literal(state.clone(), ';') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), ',') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "Split" }))
    }
}
